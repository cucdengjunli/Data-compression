# 实验二 图像文件的读写与转换
## 一.实验原理
**bmp文件在windows.h中的定义如下**

1.文件头
```cpp
typedef struct tagBITMAPFILEHEADER {
        WORD    bfType; //用于标识BMP和DIB文件
        DWORD   bfSize; //BMP文件的大小（单位为字节）
        WORD    bfReserved1;  //保留；实际值因创建程序而异
        WORD    bfReserved2;  //保留；实际值因创建程序而异
        DWORD   bfOffBits;  //位图数据（像素数组）的地址偏移，也就是起始地址。
} BITMAPFILEHEADER;
```
2.信息头
```cpp
typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;  //该头结构的大小（40字节）
        LONG       biWidth; //位图宽度，单位为像素（有符号整数）
        LONG       biHeight;  //位图高度，单位为像素（有符号整数）
        WORD       biPlanes;  //	色彩平面数；只有1为有效值
        WORD       biBitCount;  //每个像素所占位数，即图像的色深。典型值为1、4、8、16、24和32
        DWORD      biCompression; //  所使用的压缩方法
        DWORD      biSizeImage; //  图像大小
        LONG       biXPelsPerMeter ;  //	图像的横向分辨率，单位为像素每米（有符号整数）
        LONG       biYPelsPerMeter; //	图像的纵向分辨率，单位为像素每米（有符号整数
        DWORD      biClrUsed; //调色板的颜色数，为0时表示颜色数为默认的2色深个
        DWORD      biClrImportant;  //重要颜色数，为0时表示所有颜色都是重要的；通常不使用本项
} BITMAPINFOHEADER;
```
3.调色板
```cpp
typedef struct tagRGBQUAD {
        BYTE    rgbBlue; 
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
```
## 二.实验步骤
+ 1.读取bmp文件的文件头和信息头以获取与图片有关的信息
+ 2.根据图像的比特数获得RGB数据
+ 3.将RGB流转换成YUV流
## 三.关键代码
**1.读取文件头和信息头**

```cpp
BITMAPFILEHEADER head;
BITMAPINFOHEADER info;
fread(&head, 1, sizeof(head), bmpfile);
fread(&info, 1, sizeof(info), bmpfile);
```
**2.24bit**

```cpp
if (info.biBitCount == 24) {
			rgbout = (BYTE *)malloc(size);
			fread(rgbout, 1, size, bmpfile);
			write_yuvfile(rgbout, height, width, yuvfile);
			free(rgbout);
		}
```
**3.16bit**

**16bit有两种格式，一是RGB都是5bit,剩下一比特没用,二是RGB分别是5bit, 6bit, 5bit，为什么G要多一个比特，因为亮度信号的表达式中绿色占的比重打。值得注意一点的是，555格式和565格式的颜色信息起始地址不一样，565格式在信息头结束后还需要偏移16字节！如何获得RGB的数据？可通过移位操作获取，具体见下代码**
```cpp
else if (info.biBitCount == 16) {

			int tem_size = width * height;
			
			BYTE pow2_5 = (BYTE)(pow(2, 5) - 1);
			BYTE pow2_6 = (BYTE)(pow(2, 6) - 1);

			rgbout = (BYTE *)malloc(size);
			WORD *raw_data = (WORD *)malloc(tem_size * 2);

			if (head.bfOffBits == 70) { //565格式 偏移量是70 = 54 + 16
				WORD *kong = (WORD *)malloc(16);
				fread(kong, 1, 16, bmpfile);

				fread(raw_data, 2, tem_size, bmpfile);
				
				for (int i = 0, j = 0; i < (int)size; i += 3) {
					WORD tem = raw_data[j];
					rgbout[i + 2] = (((tem >> 11) & pow2_5) << 3);
					rgbout[i + 1] = (((tem >> 5) & pow2_6) << 2);
					rgbout[i] = ((tem & pow2_5) << 3);
					j++;
				}
			}
			
			else{ //555格式，偏移量是54
				fread(raw_data, 2, tem_size, bmpfile);

				for (int i = 0, j = 0; i < (int)size; i += 3) {
					WORD tem = raw_data[j];
					rgbout[i + 2] = (((tem >> 10) & pow2_5) << 3);
					rgbout[i + 1] = (((tem >> 5) & pow2_5) << 3);
					rgbout[i] = ((tem & pow2_5) << 3);
					j++;
				}
			}

			write_yuvfile(rgbout, height, width, yuvfile);
			free(rgbout);
			free(raw_data);
		}
```
**4.8bit
```cpp
else if (info.biBitCount == 8) {
			BYTE plane_table[256][4];
			BYTE *plane = (BYTE *)malloc(256 * 4);
			fread(plane, 1, 256 * 4, bmpfile); //这里我利用一个二维数组存调色板
			for (int i = 0; i < 256; i++) {
				plane_table[i][0] = plane[0];
				plane_table[i][1] = plane[1];
				plane_table[i][2] = plane[2];
				plane_table[i][3] = plane[3];
				plane += 4;
			}

			BYTE *raw_data = (BYTE *)malloc(width * height);
			fread(raw_data, 1, width * height, bmpfile);
			rgbout = (BYTE *)malloc(width * height * 3);
			
			for (int i = 0, j = 0; i < (int)(width * height * 3); i += 3) {
				int index = raw_data[j];
				rgbout[i] = plane_table[index][0];
				rgbout[i + 1] = plane_table[index][1];
				rgbout[i + 2] = plane_table[index][2];
				j++;
			}

			write_yuvfile(rgbout, height, width, yuvfile);

			free(rgbout);
			free(raw_data);
		}
```
## 四.实验结果
 
## 五.实验结论
```

```
## 六.总结


