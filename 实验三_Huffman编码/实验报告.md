# 实验三 Huffman编码
## 一.实验原理

本次实验的实验原理是无失真信源编码的哈夫曼编码。由信息论相关知识可知，编码后平均码长的下界是信源熵，通过哈夫曼编码，平均码长可以接近下界并且编出来的码是一种即时码。哈夫曼编码由两种方式，一种是构建一颗二叉树来获得每一个信源符号唯一的码字，另一种构建三个数组，建立码字，符号，码长之间的关系，输出的码字直接查表即可，比建哈夫曼树这种方法要快很多。为了深入理解哈夫曼编码以及二叉树这种数据结构，该实验采用的是第一种方法。

二叉树的结构如下图所示
![二叉树]()

树上的每个节点我们用一个结构体表示：
```cpp
struct Node{
	Node *parent, *l_child, *r_child;
	BYTE data;
	int cnt;
	int code_len;
	bool is_leaf;
	char code[20];
	Node(){
		parent = NULL;
		l_child = NULL;
		r_child = NULL;
		data = '0';
		cnt = 0;
		is_leaf = false;
	}
	Node(Node *p, Node *l, Node*r, BYTE ch, int num, bool leaf){
		parent = p;
		l_child = l;
		r_child = r;
		data = ch;
		cnt = num;
		is_leaf = leaf;
	}
};
```
该结构体里面包括左右孩子和父亲（方便以链表的形式构建树）；该节点对应的字符，如果不是叶子结点，字符为空；码字和码长，方便统计和获得编码后输出文件；是否是叶子结点，为了树的遍历；以及默认构造函数和带参数的构造函数。

## 二.实验步骤

+ 首先对读入的字符进行频率统计(字符取值是[0, 255])，并记录总的字符数。同时，我们new一个该字符对应的结点。
+ 接着利用已有的结点，根据哈夫曼树的构建规则构建这课二叉树。
+ 然后再读一遍输入文件，对每个字符进行编码，并输出到编码后的文件。
+ 最后，计算信源的熵，编码后的平均码长，压缩比，并将频率，码长，码字等信息输出到txt文件中，导入exel，绘制成表格。

## 三.关键代码

在这里，我仅对关键代码进行分析。
+ 以二进制的形式读入文件，每次读一个字符，在读入文件的同时new一个结构体，并赋值。这里我用了一个结构体指针数组，并以0到255的值作为下标，这样就可以O(1)的速度找到该字符对应的结构体，非常方便！比如读入的字符是'a'，那么index[(int)a]就是a字符对应的结构体的指针。
```cpp
input_file = fopen(in_name, "rb"); //rb模式 而不是r模式！！！
if(!input_file){
	cout << "can not open file" << endl;
	return 0;
}
while((c = fgetc(input_file)) != EOF){
	if(!index[c]){
		Node *node = new Node();
		index[c] = node;
		node->data = c;
		node->is_leaf = true;
	}
	(index[c]->cnt)++;
	total_cnt++;
}
```
+ 在构建哈夫曼树的时候，我利用了优先队列这种数据结构。我们知道，构建哈夫曼树需要对字符频率进行排序， 然后每次取频率最小和次小的两个字符作为叶子结点，时间复杂度是O(nlogn)，但是如果我用优先队列去维护当前待排序的元素，我既能方便的获得评率最小和次小的两个字符，时间复杂也会降低，是O(logn)。通过以下几行代码，一颗哈夫曼树就构建完成了。
```cpp
for(int i = 0; i < 256; i++){
	if(index[i]) pq.push(index[i]);//把文件中存在的字符放入优先队列中
}
while(pq.size() != 1){
	Node *left = pq.top(); pq.pop();
	Node *right = pq.top();pq.pop();
	Node *fa = new Node(NULL, right, left, '0', (left->cnt) + (right->cnt), false);
	left->parent = fa; right->parent = fa;
	pq.push(fa);//把new出来的父亲结点放入优先队列中
}
```

## 四.实验结果

## 五.实验结论




